# ContextLib.jl

ContextLib is used to keep track of execution context.  The context data is kept in a stack data structure.  When a function is called, the context is saved.  When the function exits, the context is restored.  Hence, any change to the context during execution is visible to current and called functions only.

Participation of context tracking is voluntary - you must annotate functions with `@ctx` macro to get in the game.  The easiest way to append data to the context is to use the `@memo` macro in front of an assignment statement or a variable reference. Context data is automatically logged when using the `ContextLogger`.

## Motivation

Suppose that we are processing a web request.  We may want to create a request id to keep track of the request and include the request id whenever we write anything to the log file.

It may seems somewhat redundant but it is invaluable in tracing production problems and analyzing system performance.  Imagine that two users are hitting the same web request at the same time.  If we look at the log file, everything could be interleaving and it would be quite confusing without the context, in this case, a request id or user id.

## Usage

Just 3 simple steps:

1. Annotate functions with `@ctx` macro to participate in context tracking
2. Use `@memo` macro to append data to the context
3. Use the `ContextLogger` for logging context data

Example:

```julia
julia> using ContextLib, Logging

julia> @ctx function foo()
           @memo x = 1
           bar()
           @info "after bar"
       end;

julia> @ctx function bar()
           y = 2
           @info "inside bar" y
       end;

julia> with_logger(ContextLogger()) do
           foo()
       end
2020-03-01T00:35:41.883-08:00 level=INFO message="inside bar" x=1 y=2
2020-03-01T00:35:41.903-08:00 level=INFO message="after bar" x=1
```

## Working with the Context object

The `context` function returns a `Context` object with the following properties:

- `name`: name of the context, which is generated by thread id because context is a singleton per thread.
- `data`: the data being tracked by the context.  By default, it is a `Dict`.
- `generations`: number of context levels.

```julia
julia> c = context()
Context Thread-1 with 1 generation(s)

julia> c.name
"Thread-1"

julia> c.data
Dict{Any,Any} with 0 entries
```

## TODO

We may do some of the cool things below:

- Allow registering pre/post hooks for specific context updates. For example, we can do something special when function C is called from function A but not from function B.
- ContextLogger should accept any kind of formatter that can work with Dicts.
-

