# ContextTools.jl

ContextTools is used to keep track of execution context at run time.  Rather than passing a context object around, it keeps the context in a global variable and provides access via a single function - `context`.

The easiest way to add data to a Context object is to use the `@memo` macro for an assignment statement.  Alternatively, you can just `push!` a key-value pair as Context is backed by a Dict store by default.  To keep track of the context during run time, annotate functions with `@ctx` macro. 

## Motivation

This package is conceived to satisfy the need of logging contextual data with ease.  For example, when processing a data request, we may work through several functions.  We use `@info` logging statement everywhere, but for the same request we want to output contexual information such as a UUID, request id, etc.

## Usage

### Tracking context using `@ctx` and `@memo` macros

```julia
julia> @ctx function foo()
           @memo x = 1
           bar()
           @info context().data
       end "Foo";

julia> @ctx function bar()
           @memo y = 2
           @info context().data
       end;

julia> foo()
[ Info: Dict{Any,Any}("x" => 1,"_ContextPath" => "Foo.bar","y" => 2)
[ Info: Dict{Any,Any}("x" => 1,"_ContextPath" => "Foo")
```

### Working with the Context object

The `context` function returns a `Context` object with the following properties:

- `name`: name of the context, which is generated by thread id because context is a singleton per thread.
- `data`: the data being tracked by the context.  By default, it is a `Dict`.

```julia
julia> c = context()
Context Thread-1 with 1 generation(s)

julia> c.name
"Thread-1"

julia> c.data
Dict{Any,Any} with 0 entries
```

### Using a different data type for storing context

The contextual data is stored in a `Dict` object by default.  It is not mandatory, however.  The user has ability to track context using any data type as long as it supports the following Base functions - `push!`, `empty!`, and `length`.

For example, to track context with an array, we can do the following:

```julia
julia> c = context(ContextTools.global_context_name(), Vector())
Context Thread-1 with 1 generation(s)

julia> push!(c, "hello");

julia> push!(c, "world");

julia> c.data
2-element Array{Any,1}:
 "hello"
 "world"
```

### Using ContextLogger

This package comes with a simple logger that displays the context path and data in single line, key-value pair format.  This is useful for log analysis programs that parses and index log data in a database.

Continue with the above example, 

```julia
julia> context_logger = ContextLogger()
ContextLogger(Base.TTY(RawFD(0x0000000f) open, 0 bytes waiting), Info)

julia> with_logger(context_logger) do
           foo()
       end
2020-01-14T10:12:40.659-08:00 level=INFO _ContextPath=foo a=1 b=2
2020-01-14T10:12:40.673-08:00 level=INFO _ContextPath=foo.bar a=1 b=2 c=3
2020-01-14T10:12:40.673-08:00 level=INFO _ContextPath=foo.bar.cool a=1 b=2 c=3
2020-01-14T10:12:40.673-08:00 level=INFO _ContextPath=foo a=1 b=2
```
